<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>radio.data.datamodules.klu_apc2 API documentation</title>
<meta name="description" content="KLU_APC2 Data Module" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>radio.data.datamodules.klu_apc2</code></h1>
</header>
<section id="section-intro">
<p>KLU_APC2 Data Module</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding=utf-8
&#34;&#34;&#34;
KLU_APC2 Data Module
&#34;&#34;&#34;

from typing import Any, Callable, List, Optional, Tuple, Union
from pathlib import Path
import re
from collections import OrderedDict
import random
import matplotlib.pyplot as plt  # type: ignore
import numpy as np
import torchio as tio  # type: ignore
from radio.settings.pathutils import is_dir_or_symlink, PathType
from ..visiondatamodule import VisionDataModule

__all__ = [&#34;KLUAPC2DataModule&#34;, &#34;plot_klu&#34;]


def plot_klu(batch: dict,
             num_imgs: int = 5,
             slice_num: int = 150,
             train: bool = True) -&gt; None:
    &#34;&#34;&#34;plot images and labels from a batch of train images&#34;&#34;&#34;
    modalities = [&#34;T1w&#34;, &#34;T2w&#34;, &#34;FLAIR&#34;, &#34;WMH&#34;
                  ] if train else [&#34;T1w&#34;, &#34;T2w&#34;, &#34;FLAIR&#34;]
    images = {}
    for modality in batch.keys():
        if modality in modalities:
            data = batch[modality][&#34;data&#34;]
            batch_size = data.shape[0]
            image_shape = data.shape[2:]
            label_shape = data.shape[2:]
            images[modality] = data

    assert num_imgs &lt;= batch_size
    samples = random.sample(range(0, batch_size), num_imgs)

    if train:
        print(f&#34;image shape: {image_shape}, label shape: {label_shape}&#34;)
    else:
        print(f&#34;image shape: {image_shape}&#34;)

    num_images = len(images.keys())
    _, axs = plt.subplots(nrows=num_imgs, ncols=num_images, squeeze=False)
    for row_idx, img_idx in enumerate(samples):
        for idx, (mod, data) in enumerate(images.items()):
            # Plot images
            axis = axs[row_idx, idx]
            axis.set(xticklabels=[], yticklabels=[], xticks=[], yticks=[])
            img = data[img_idx].permute(0, 3, 1, 2).numpy().squeeze()
            if mod in [&#34;T1w&#34;, &#34;T2w&#34;, &#34;FLAIR&#34;]:
                axis.imshow(img[slice_num, :, :], cmap=&#34;gray&#34;)
            # Plot label
            if mod in [&#34;WMH&#34;] and train:
                axis.imshow(img[0, slice_num, :, :], cmap=&#34;binary&#34;)

    for column, modality in enumerate(images.keys()):
        plt.sca(axs[0, column])
        plt.title(label=modality, size=15)
    plt.show()


class KLUAPC2DataModule(VisionDataModule):
    &#34;&#34;&#34;
    KLU APC2 Data Module.

    Typical Workflow
    ----------------
    klu = KLUAPC2DataModule()
    klu.prepare_data() # download
    klu.setup(stage) # process and split
    klu.teardown(stage) # clean-up

    Parameters
    ----------
    root : Path or str, optional
        Root directory of dataset.
        Default = ``&#39;&#39;/media/cerebro/Studies/KLU_APC2/Public/Analysis/data&#39;&#39;``.
    step : str, optional
        Which processing step to use.
        Default = ``&#39;&#39;step02_structural_processing&#39;&#39;``.
    train_transforms : Callable, optional
        A function/transform that takes in a sample and returns a
        transformed version, e.g, ``torchvision.transforms.RandomCrop``.
    val_transforms : Callable, optional
        A function/transform that takes in a sample and returns a
        transformed version, e.g, ``torchvision.transforms.RandomCrop``.
    test_transforms : Callable, optional
        A function/transform that takes in a sample and returns a
        transformed version, e.g, ``torchvision.transforms.RandomCrop``.
    use_augmentation : bool, optional
        If ``True``, augment samples during the ``fit`` stage.
        Default = ``True``.
    batch_size : int, optional
        How many samples per batch to load. Default = ``32``.
    shuffle : bool, optional
        Whether to shuffle the data at every epoch. Default = ``False``.
    num_workers : int, optional
        How many subprocesses to use for data loading. ``0`` means that the
        data will be loaded in the main process. Default: ``0``.
    pin_memory : bool, optional
        If ``True``, the data loader will copy Tensors into CUDA pinned memory
        before returning them.
    drop_last : bool, optional
        Set to ``True`` to drop the last incomplete batch, if the dataset size
        is not divisible by the batch size. If ``False`` and the size of
        dataset is not divisible by the batch size, then the last batch will be
        smaller. Default = ``False``.
    num_folds : int, optional
        Number of folds. Must be at least ``2``. ``2`` corresponds to a single
        train/validation split. Default = ``2``.
    val_split : int or float, optional
        If ``num_folds = 2``, then ``val_split`` specify how the
        train_dataset should be split into train/validation datasets. If
        ``num_folds &gt; 2``, then it is not used. Default = ``0.2``.
    dims : List[int], optional
        Max spatial dimensions across subjects&#39; images.
        Default = ``[320, 256, 256]``.
    seed : int, optional
        When `shuffle` is True, `seed` affects the ordering of the indices,
        which controls the randomness of each fold. It is also use to seed the
        RNG used by RandomSampler to generate random indexes and
        multiprocessing to generate `base_seed` for workers. Pass an int for
        reproducible output across multiple function calls. Default = ``41``.
    &#34;&#34;&#34;
    name: str = &#34;klu_apc2&#34;
    dataset_cls = tio.SubjectsDataset

    def __init__(
        self,
        *args: Any,
        root: PathType = Path(
            &#39;/media/cerebro/Studies/KLU_APC2/Public/Analysis/data&#39;),
        step: str = &#39;step02_structural_processing&#39;,
        train_transforms: Optional[Callable] = None,
        val_transforms: Optional[Callable] = None,
        test_transforms: Optional[Callable] = None,
        use_augmentation: bool = True,
        batch_size: int = 32,
        shuffle: bool = True,
        num_workers: int = 0,
        pin_memory: bool = True,
        drop_last: bool = False,
        num_folds: int = 2,
        val_split: Union[int, float] = 0.2,
        modalities: List[str] = [&#34;T1w&#34;, &#34;FLAIR&#34;, &#34;T2w&#34;],
        labels: List[str] = [&#34;WMH&#34;],
        dims: List[int] = [256, 256, 256],
        seed: int = 41,
        **kwargs: Any,
    ) -&gt; None:
        super().__init__(
            *args,
            root=root,
            train_transforms=train_transforms,
            val_transforms=val_transforms,
            test_transforms=test_transforms,
            batch_size=batch_size,
            shuffle=shuffle,
            num_workers=num_workers,
            pin_memory=pin_memory,
            drop_last=drop_last,
            num_folds=num_folds,
            val_split=val_split,
            seed=seed,
            **kwargs,
        )
        self.step = step
        self.modalities = modalities
        self.labels = labels
        self.dims = dims
        self.use_augmentation = use_augmentation

    def get_max_shape(self, subjects: List[tio.Subject]) -&gt; List[int]:
        &#34;&#34;&#34;
        Get max shape.

        Parameters
        ----------
        subjects : List[tio.Subject]
            List of TorchIO Subject objects.

        Returns
        -------
        _ : np.ndarray((1, 3), np.int_)
            Max height, width and depth across all subjects.
        &#34;&#34;&#34;
        dataset = self.dataset_cls(subjects)
        shapes = np.array([
            image.spatial_shape for subject in dataset
            for image in subject.get_images()
        ])
        return shapes.max(axis=0).tolist()

    def prepare_data(self, *args: Any, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;Verify data directory exists.&#34;&#34;&#34;
        if not is_dir_or_symlink(self.root):
            raise OSError(&#34;Study data directory not found!&#34;)

    def setup(self, stage: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;
        Creates train, validation and test collection of samplers.

        Parameters
        ----------
        stage: Optional[str]
            Either ``&#39;fit``, ``&#39;validate&#39;``, ``&#39;test&#39;``, or ``&#39;predict&#39;``.
            If stage = None, set-up all stages. Default = None.
        &#34;&#34;&#34;
        # dims = []
        if stage == &#34;fit&#34; or stage is None:
            train_transforms = (self.default_transforms()
                                if self.train_transforms is None else
                                self.train_transforms)

            val_transforms = (self.default_transforms()
                              if self.val_transforms is None else
                              self.val_transforms)

            train_subjects = self.get_subjects()
            # dims.append([self.get_max_shape(train_subjects)])
            self.train_dataset = self.dataset_cls(train_subjects,
                                                  transform=train_transforms)
            self.val_dataset = self.dataset_cls(train_subjects,
                                                transform=val_transforms)

            self.validation = self.val_cls(train_dataset=self.train_dataset,
                                           val_dataset=self.val_dataset,
                                           batch_size=self.batch_size,
                                           shuffle=self.shuffle,
                                           num_workers=self.num_workers,
                                           pin_memory=self.pin_memory,
                                           drop_last=self.drop_last,
                                           num_folds=self.num_folds,
                                           seed=self.seed)

            self.validation.setup(self.val_split)
            self.size_train = self.validation.size_train
            self.size_val = self.validation.size_val

        if stage == &#34;test&#34; or stage is None:
            test_transforms = (self.default_transforms()
                               if self.test_transforms is None else
                               self.test_transforms)
            test_subjects = self.get_subjects(train=False)
            # dims.append([self.get_max_shape(test_subjects)])
            test_dataset = self.dataset_cls(test_subjects,
                                            transform=test_transforms)
            self.test_datasets.append(test_dataset)
            self.test_datasets.append(test_dataset)
            self.size_test = min([len(data) for data in self.test_datasets])

        if stage == &#34;predict&#34; or stage is None:
            predict_transforms = (self.default_transforms()
                                  if self.test_transforms is None else
                                  self.test_transforms)
            predict_subjects = self.get_subjects(train=False)
            predict_dataset = self.dataset_cls(predict_subjects,
                                               transform=predict_transforms)
            self.predict_datasets.append(predict_dataset)
            self.size_predict = min(
                [len(data) for data in self.predict_datasets])

        # self.dims = np.concatenate(dims, axis=0).max(axis=0).tolist()

    def get_paths(self) -&gt; OrderedDict[Tuple[str, str], Path]:
        &#34;&#34;&#34;
        Get subject and scan IDs and the respective paths from the study data
        directory.

        Returns
        -------
        _ : Tuple[List[Path], List[Path]]
            Paths to train images and labels.
        &#34;&#34;&#34;
        paths = OrderedDict()
        # 6-digit subject ID, followed by 6-digit scan ID
        regex = re.compile(r&#34;(\d{6})/(\d{6})&#34;)
        for item in self.root.glob(&#34;*/*&#34;):
            if item.is_dir() and not item.name.startswith(&#39;.&#39;):
                match = regex.search(str(item))
                if match is not None:
                    subj_id, scan_id = match.groups()
                    paths[(subj_id, scan_id)] = self.root / subj_id / scan_id

        return paths

    @staticmethod
    def split_dict(dictionary: OrderedDict,
                   test_split: Union[int, float] = 0.2,
                   shuffle: bool = True) -&gt; Tuple[OrderedDict, OrderedDict]:
        &#34;&#34;&#34;Split dict into two.&#34;&#34;&#34;
        len_dict = len(dictionary)
        if isinstance(test_split, int):
            train_len = len_dict - test_split
            splits = [train_len, test_split]
        elif isinstance(test_split, float):
            test_len = int(np.floor(test_split * len_dict))
            train_len = len_dict - test_len
            splits = [train_len, test_len]
        else:
            raise ValueError(f&#34;Unsupported type {type(test_split)}&#34;)
        indexes = list(range(len_dict))
        if shuffle:
            np.random.shuffle(indexes)
        train_idx, test_idx = indexes[:splits[0]], indexes[:splits[1]]

        dictionary_list = list(dictionary.items())

        train_dict = OrderedDict([
            value for idx, value in enumerate(dictionary_list)
            if idx in train_idx
        ])
        test_dict = OrderedDict([
            value for idx, value in enumerate(dictionary_list)
            if idx in test_idx
        ])
        return train_dict, test_dict

    def get_subject_dicts(
        self,
        step: str = &#39;step06_WMHz_new&#39;,
        modalities: List[str] = [&#39;T1w&#39;, &#39;FLAIR&#39;],
        labels: List[str] = [&#39;WMH&#39;],
    ) -&gt; Tuple[OrderedDict[Tuple[str, str], dict], OrderedDict[Tuple[str, str],
                                                               dict]]:
        &#34;&#34;&#34;
        Get paths to nii files for train images and labels.

        Returns
        -------
        _ : Tuple[List[Path], List[Path]]
            Paths to train images and labels.
        &#34;&#34;&#34;
        paths_dict = self.get_paths()
        train_paths_dict, test_paths_dict = self.split_dict(paths_dict)
        training_dict = OrderedDict()
        testing_dict = OrderedDict()

        # Get training dict
        for (subj_id, scan_id), path in train_paths_dict.items():
            training_dict[(subj_id, scan_id)] = {
                &#34;subj_id&#34;: subj_id,
                &#34;scan_id&#34;: scan_id
            }
            for mod in modalities:
                if mod == &#34;T1w&#34;:
                    t1_path = path / step / &#39;T1.nii&#39;
                    if t1_path.is_file():
                        training_dict[(subj_id, scan_id)].update(
                            {&#39;T1w&#39;: tio.ScalarImage(t1_path)})
                    else:
                        training_dict.pop((subj_id, scan_id), None)
                if mod == &#34;FLAIR&#34;:
                    flair_path = path / step / f&#39;{scan_id}_FLAIR.nii&#39;
                    if flair_path.is_file():
                        training_dict[(subj_id, scan_id)].update(
                            {&#39;FLAIR&#39;: tio.ScalarImage(flair_path)})
                    else:
                        training_dict.pop((subj_id, scan_id), None)

            for lab in labels:
                if lab == &#34;WMH&#34;:
                    wmh_path = path / step / f&#39;{scan_id}_FLAIR_wmh.nii&#39;
                    if wmh_path.is_file():
                        training_dict[(subj_id, scan_id)].update(
                            {&#39;WMH&#39;: tio.LabelMap(wmh_path)})
                    else:
                        training_dict.pop((subj_id, scan_id), None)

        # Get testing dict
        for (subj_id, scan_id), path in test_paths_dict.items():
            testing_dict[(subj_id, scan_id)] = {
                &#34;subj_id&#34;: subj_id,
                &#34;scan_id&#34;: scan_id
            }
            for mod in modalities:
                if mod == &#34;T1w&#34;:
                    t1_path = path / step / &#39;T1.nii&#39;
                    if t1_path.is_file():
                        testing_dict[(subj_id, scan_id)].update(
                            {&#39;T1w&#39;: tio.ScalarImage(t1_path)})
                    else:
                        testing_dict.pop((subj_id, scan_id), None)
                if mod == &#34;FLAIR&#34;:
                    flair_path = path / step / f&#39;{scan_id}_FLAIR.nii&#39;
                    if flair_path.is_file():
                        testing_dict[(subj_id, scan_id)].update(
                            {&#39;FLAIR&#39;: tio.ScalarImage(flair_path)})
                    else:
                        testing_dict.pop((subj_id, scan_id), None)

        return training_dict, testing_dict

    def get_subjects(self, train: bool = True) -&gt; List[tio.Subject]:
        &#34;&#34;&#34;
        Get TorchIO Subject train and test subjects.

        Parameters
        ----------
        train : bool, optional
            If True, return a loader for the train dataset, else for the
            validation dataset. Default = ``True``.

        Returns
        -------
        _ : List[tio.Subject]
            TorchIO Subject train or test subjects.
        &#34;&#34;&#34;
        if train:
            training_dict, _ = self.get_subject_dicts(
                step=self.step, modalities=self.modalities, labels=self.labels)
            train_subjects = []
            for _, subject_dict in training_dict.items():
                # &#39;image&#39; and &#39;label&#39; are arbitrary names for the images
                subject = tio.Subject(subject_dict)
                train_subjects.append(subject)
            return train_subjects

        _, testing_dict = self.get_subject_dicts(step=self.step,
                                                 modalities=self.modalities,
                                                 labels=self.labels)
        test_subjects = []
        for _, subject_dict in testing_dict.items():
            subject = tio.Subject(subject_dict)
            test_subjects.append(subject)

        return test_subjects

    def get_preprocessing_transforms(
        self,
        size: Optional[List[int]] = [256, 256, 256],
        t2w_present: bool = False,
        flair_present: bool = False,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        Get preprocessing transorms to apply to all subjects.

        Returns
        -------
        preprocess : tio.Compose
            All preprocessing steps that should be applied to all subjects.
        &#34;&#34;&#34;
        preprocess_list = []

        # Use standard orientation for all images
        preprocess_list.append(tio.ToCanonical())

        # if t2w_present and not flair_present:
        #     preprocess_list.append(tio.Resample(&#39;T2w&#39;))
        # elif not t2w_present and flair_present:
        #     preprocess_list.append(tio.Resample(&#39;FLAIR&#39;))
        # elif t2w_present and flair_present:
        #     preprocess_list.append(tio.Resample(&#39;FLAIR&#39;))
        # else:

        # Resample to T1w
        preprocess_list.append(tio.Resample(&#39;T1w&#39;))

        if size is None:
            train_subjects = self.get_subjects()
            test_subjects = self.get_subjects(train=False)
            shape = self.get_max_shape(train_subjects + test_subjects)
        else:
            shape = self.dims

        preprocess_list.extend([
            tio.RescaleIntensity((-1, 1)),
            tio.CropOrPad(shape),
            tio.EnsureShapeMultiple(8),  # for the U-Net
            tio.OneHot()
        ])

        return tio.Compose(preprocess_list)

    @staticmethod
    def get_augmentation_transforms() -&gt; Callable:
        &#34;&#34;&#34;&#34;
        Get augmentation transorms to apply to subjects during training.

        Returns
        -------
        augment : tio.Compose
            All augmentation steps that should be applied to subjects during
            training.
        &#34;&#34;&#34;
        augment = tio.Compose([
            tio.RandomAffine(),
            tio.RandomGamma(p=0.5),
            tio.RandomNoise(p=0.5),
            tio.RandomMotion(p=0.1),
            tio.RandomBiasField(p=0.25),
        ])
        return augment

    def default_transforms(self, stage: Optional[str] = None) -&gt; Callable:
        &#34;&#34;&#34;
        Default transforms and augmentations for the dataset.

        Parameters
        ----------
        stage: Optional[str]
            Either ``&#39;fit``, ``&#39;validate&#39;``, ``&#39;test&#39;``, or ``&#39;predict&#39;``.
            If stage = None, set-up all stages. Default = None.

        Returns
        -------
        _: Callable
            All preprocessing steps (and if ``&#39;fit&#39;``, augmentation steps too)
            that should be applied to the subjects.
        &#34;&#34;&#34;
        transforms = []
        t2w_present = bool(&#34;T2w&#34; in self.modalities)
        flair_present = bool(&#34;FLAIR&#34; in self.modalities)
        preprocess = self.get_preprocessing_transforms(
            size=self.dims,
            t2w_present=t2w_present,
            flair_present=flair_present)
        transforms.append(preprocess)
        if stage == &#34;fit&#34; or stage is None and self.use_augmentation:
            augment = self.get_augmentation_transforms()
            transforms.append(augment)

        return tio.Compose(transforms)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="radio.data.datamodules.klu_apc2.plot_klu"><code class="name flex">
<span>def <span class="ident">plot_klu</span></span>(<span>batch: dict, num_imgs: int = 5, slice_num: int = 150, train: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>plot images and labels from a batch of train images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_klu(batch: dict,
             num_imgs: int = 5,
             slice_num: int = 150,
             train: bool = True) -&gt; None:
    &#34;&#34;&#34;plot images and labels from a batch of train images&#34;&#34;&#34;
    modalities = [&#34;T1w&#34;, &#34;T2w&#34;, &#34;FLAIR&#34;, &#34;WMH&#34;
                  ] if train else [&#34;T1w&#34;, &#34;T2w&#34;, &#34;FLAIR&#34;]
    images = {}
    for modality in batch.keys():
        if modality in modalities:
            data = batch[modality][&#34;data&#34;]
            batch_size = data.shape[0]
            image_shape = data.shape[2:]
            label_shape = data.shape[2:]
            images[modality] = data

    assert num_imgs &lt;= batch_size
    samples = random.sample(range(0, batch_size), num_imgs)

    if train:
        print(f&#34;image shape: {image_shape}, label shape: {label_shape}&#34;)
    else:
        print(f&#34;image shape: {image_shape}&#34;)

    num_images = len(images.keys())
    _, axs = plt.subplots(nrows=num_imgs, ncols=num_images, squeeze=False)
    for row_idx, img_idx in enumerate(samples):
        for idx, (mod, data) in enumerate(images.items()):
            # Plot images
            axis = axs[row_idx, idx]
            axis.set(xticklabels=[], yticklabels=[], xticks=[], yticks=[])
            img = data[img_idx].permute(0, 3, 1, 2).numpy().squeeze()
            if mod in [&#34;T1w&#34;, &#34;T2w&#34;, &#34;FLAIR&#34;]:
                axis.imshow(img[slice_num, :, :], cmap=&#34;gray&#34;)
            # Plot label
            if mod in [&#34;WMH&#34;] and train:
                axis.imshow(img[0, slice_num, :, :], cmap=&#34;binary&#34;)

    for column, modality in enumerate(images.keys()):
        plt.sca(axs[0, column])
        plt.title(label=modality, size=15)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule"><code class="flex name class">
<span>class <span class="ident">KLUAPC2DataModule</span></span>
<span>(</span><span>*args: Any, root: Union[str, pathlib.Path] = PosixPath('/media/cerebro/Studies/KLU_APC2/Public/Analysis/data'), step: str = 'step02_structural_processing', train_transforms: Optional[Callable] = None, val_transforms: Optional[Callable] = None, test_transforms: Optional[Callable] = None, use_augmentation: bool = True, batch_size: int = 32, shuffle: bool = True, num_workers: int = 0, pin_memory: bool = True, drop_last: bool = False, num_folds: int = 2, val_split: Union[int, float] = 0.2, modalities: List[str] = ['T1w', 'FLAIR', 'T2w'], labels: List[str] = ['WMH'], dims: List[int] = [256, 256, 256], seed: int = 41, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>KLU APC2 Data Module.</p>
<h2 id="typical-workflow">Typical Workflow</h2>
<p>klu = KLUAPC2DataModule()
klu.prepare_data() # download
klu.setup(stage) # process and split
klu.teardown(stage) # clean-up</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>Path</code> or <code>str</code>, optional</dt>
<dd>Root directory of dataset.
Default = <code>''/media/cerebro/Studies/KLU_APC2/Public/Analysis/data''</code>.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Which processing step to use.
Default = <code>''step02_structural_processing''</code>.</dd>
<dt><strong><code>train_transforms</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>A function/transform that takes in a sample and returns a
transformed version, e.g, <code>torchvision.transforms.RandomCrop</code>.</dd>
<dt><strong><code>val_transforms</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>A function/transform that takes in a sample and returns a
transformed version, e.g, <code>torchvision.transforms.RandomCrop</code>.</dd>
<dt><strong><code>test_transforms</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>A function/transform that takes in a sample and returns a
transformed version, e.g, <code>torchvision.transforms.RandomCrop</code>.</dd>
<dt><strong><code>use_augmentation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, augment samples during the <code>fit</code> stage.
Default = <code>True</code>.</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How many samples per batch to load. Default = <code>32</code>.</dd>
<dt><strong><code>shuffle</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to shuffle the data at every epoch. Default = <code>False</code>.</dd>
<dt><strong><code>num_workers</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How many subprocesses to use for data loading. <code>0</code> means that the
data will be loaded in the main process. Default: <code>0</code>.</dd>
<dt><strong><code>pin_memory</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, the data loader will copy Tensors into CUDA pinned memory
before returning them.</dd>
<dt><strong><code>drop_last</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set to <code>True</code> to drop the last incomplete batch, if the dataset size
is not divisible by the batch size. If <code>False</code> and the size of
dataset is not divisible by the batch size, then the last batch will be
smaller. Default = <code>False</code>.</dd>
<dt><strong><code>num_folds</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of folds. Must be at least <code>2</code>. <code>2</code> corresponds to a single
train/validation split. Default = <code>2</code>.</dd>
<dt><strong><code>val_split</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>If <code>num_folds = 2</code>, then <code>val_split</code> specify how the
train_dataset should be split into train/validation datasets. If
<code>num_folds &gt; 2</code>, then it is not used. Default = <code>0.2</code>.</dd>
<dt><strong><code>dims</code></strong> :&ensp;<code>List[int]</code>, optional</dt>
<dd>Max spatial dimensions across subjects' images.
Default = <code>[320, 256, 256]</code>.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>When <code>shuffle</code> is True, <code>seed</code> affects the ordering of the indices,
which controls the randomness of each fold. It is also use to seed the
RNG used by RandomSampler to generate random indexes and
multiprocessing to generate <code>base_seed</code> for workers. Pass an int for
reproducible output across multiple function calls. Default = <code>41</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KLUAPC2DataModule(VisionDataModule):
    &#34;&#34;&#34;
    KLU APC2 Data Module.

    Typical Workflow
    ----------------
    klu = KLUAPC2DataModule()
    klu.prepare_data() # download
    klu.setup(stage) # process and split
    klu.teardown(stage) # clean-up

    Parameters
    ----------
    root : Path or str, optional
        Root directory of dataset.
        Default = ``&#39;&#39;/media/cerebro/Studies/KLU_APC2/Public/Analysis/data&#39;&#39;``.
    step : str, optional
        Which processing step to use.
        Default = ``&#39;&#39;step02_structural_processing&#39;&#39;``.
    train_transforms : Callable, optional
        A function/transform that takes in a sample and returns a
        transformed version, e.g, ``torchvision.transforms.RandomCrop``.
    val_transforms : Callable, optional
        A function/transform that takes in a sample and returns a
        transformed version, e.g, ``torchvision.transforms.RandomCrop``.
    test_transforms : Callable, optional
        A function/transform that takes in a sample and returns a
        transformed version, e.g, ``torchvision.transforms.RandomCrop``.
    use_augmentation : bool, optional
        If ``True``, augment samples during the ``fit`` stage.
        Default = ``True``.
    batch_size : int, optional
        How many samples per batch to load. Default = ``32``.
    shuffle : bool, optional
        Whether to shuffle the data at every epoch. Default = ``False``.
    num_workers : int, optional
        How many subprocesses to use for data loading. ``0`` means that the
        data will be loaded in the main process. Default: ``0``.
    pin_memory : bool, optional
        If ``True``, the data loader will copy Tensors into CUDA pinned memory
        before returning them.
    drop_last : bool, optional
        Set to ``True`` to drop the last incomplete batch, if the dataset size
        is not divisible by the batch size. If ``False`` and the size of
        dataset is not divisible by the batch size, then the last batch will be
        smaller. Default = ``False``.
    num_folds : int, optional
        Number of folds. Must be at least ``2``. ``2`` corresponds to a single
        train/validation split. Default = ``2``.
    val_split : int or float, optional
        If ``num_folds = 2``, then ``val_split`` specify how the
        train_dataset should be split into train/validation datasets. If
        ``num_folds &gt; 2``, then it is not used. Default = ``0.2``.
    dims : List[int], optional
        Max spatial dimensions across subjects&#39; images.
        Default = ``[320, 256, 256]``.
    seed : int, optional
        When `shuffle` is True, `seed` affects the ordering of the indices,
        which controls the randomness of each fold. It is also use to seed the
        RNG used by RandomSampler to generate random indexes and
        multiprocessing to generate `base_seed` for workers. Pass an int for
        reproducible output across multiple function calls. Default = ``41``.
    &#34;&#34;&#34;
    name: str = &#34;klu_apc2&#34;
    dataset_cls = tio.SubjectsDataset

    def __init__(
        self,
        *args: Any,
        root: PathType = Path(
            &#39;/media/cerebro/Studies/KLU_APC2/Public/Analysis/data&#39;),
        step: str = &#39;step02_structural_processing&#39;,
        train_transforms: Optional[Callable] = None,
        val_transforms: Optional[Callable] = None,
        test_transforms: Optional[Callable] = None,
        use_augmentation: bool = True,
        batch_size: int = 32,
        shuffle: bool = True,
        num_workers: int = 0,
        pin_memory: bool = True,
        drop_last: bool = False,
        num_folds: int = 2,
        val_split: Union[int, float] = 0.2,
        modalities: List[str] = [&#34;T1w&#34;, &#34;FLAIR&#34;, &#34;T2w&#34;],
        labels: List[str] = [&#34;WMH&#34;],
        dims: List[int] = [256, 256, 256],
        seed: int = 41,
        **kwargs: Any,
    ) -&gt; None:
        super().__init__(
            *args,
            root=root,
            train_transforms=train_transforms,
            val_transforms=val_transforms,
            test_transforms=test_transforms,
            batch_size=batch_size,
            shuffle=shuffle,
            num_workers=num_workers,
            pin_memory=pin_memory,
            drop_last=drop_last,
            num_folds=num_folds,
            val_split=val_split,
            seed=seed,
            **kwargs,
        )
        self.step = step
        self.modalities = modalities
        self.labels = labels
        self.dims = dims
        self.use_augmentation = use_augmentation

    def get_max_shape(self, subjects: List[tio.Subject]) -&gt; List[int]:
        &#34;&#34;&#34;
        Get max shape.

        Parameters
        ----------
        subjects : List[tio.Subject]
            List of TorchIO Subject objects.

        Returns
        -------
        _ : np.ndarray((1, 3), np.int_)
            Max height, width and depth across all subjects.
        &#34;&#34;&#34;
        dataset = self.dataset_cls(subjects)
        shapes = np.array([
            image.spatial_shape for subject in dataset
            for image in subject.get_images()
        ])
        return shapes.max(axis=0).tolist()

    def prepare_data(self, *args: Any, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;Verify data directory exists.&#34;&#34;&#34;
        if not is_dir_or_symlink(self.root):
            raise OSError(&#34;Study data directory not found!&#34;)

    def setup(self, stage: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;
        Creates train, validation and test collection of samplers.

        Parameters
        ----------
        stage: Optional[str]
            Either ``&#39;fit``, ``&#39;validate&#39;``, ``&#39;test&#39;``, or ``&#39;predict&#39;``.
            If stage = None, set-up all stages. Default = None.
        &#34;&#34;&#34;
        # dims = []
        if stage == &#34;fit&#34; or stage is None:
            train_transforms = (self.default_transforms()
                                if self.train_transforms is None else
                                self.train_transforms)

            val_transforms = (self.default_transforms()
                              if self.val_transforms is None else
                              self.val_transforms)

            train_subjects = self.get_subjects()
            # dims.append([self.get_max_shape(train_subjects)])
            self.train_dataset = self.dataset_cls(train_subjects,
                                                  transform=train_transforms)
            self.val_dataset = self.dataset_cls(train_subjects,
                                                transform=val_transforms)

            self.validation = self.val_cls(train_dataset=self.train_dataset,
                                           val_dataset=self.val_dataset,
                                           batch_size=self.batch_size,
                                           shuffle=self.shuffle,
                                           num_workers=self.num_workers,
                                           pin_memory=self.pin_memory,
                                           drop_last=self.drop_last,
                                           num_folds=self.num_folds,
                                           seed=self.seed)

            self.validation.setup(self.val_split)
            self.size_train = self.validation.size_train
            self.size_val = self.validation.size_val

        if stage == &#34;test&#34; or stage is None:
            test_transforms = (self.default_transforms()
                               if self.test_transforms is None else
                               self.test_transforms)
            test_subjects = self.get_subjects(train=False)
            # dims.append([self.get_max_shape(test_subjects)])
            test_dataset = self.dataset_cls(test_subjects,
                                            transform=test_transforms)
            self.test_datasets.append(test_dataset)
            self.test_datasets.append(test_dataset)
            self.size_test = min([len(data) for data in self.test_datasets])

        if stage == &#34;predict&#34; or stage is None:
            predict_transforms = (self.default_transforms()
                                  if self.test_transforms is None else
                                  self.test_transforms)
            predict_subjects = self.get_subjects(train=False)
            predict_dataset = self.dataset_cls(predict_subjects,
                                               transform=predict_transforms)
            self.predict_datasets.append(predict_dataset)
            self.size_predict = min(
                [len(data) for data in self.predict_datasets])

        # self.dims = np.concatenate(dims, axis=0).max(axis=0).tolist()

    def get_paths(self) -&gt; OrderedDict[Tuple[str, str], Path]:
        &#34;&#34;&#34;
        Get subject and scan IDs and the respective paths from the study data
        directory.

        Returns
        -------
        _ : Tuple[List[Path], List[Path]]
            Paths to train images and labels.
        &#34;&#34;&#34;
        paths = OrderedDict()
        # 6-digit subject ID, followed by 6-digit scan ID
        regex = re.compile(r&#34;(\d{6})/(\d{6})&#34;)
        for item in self.root.glob(&#34;*/*&#34;):
            if item.is_dir() and not item.name.startswith(&#39;.&#39;):
                match = regex.search(str(item))
                if match is not None:
                    subj_id, scan_id = match.groups()
                    paths[(subj_id, scan_id)] = self.root / subj_id / scan_id

        return paths

    @staticmethod
    def split_dict(dictionary: OrderedDict,
                   test_split: Union[int, float] = 0.2,
                   shuffle: bool = True) -&gt; Tuple[OrderedDict, OrderedDict]:
        &#34;&#34;&#34;Split dict into two.&#34;&#34;&#34;
        len_dict = len(dictionary)
        if isinstance(test_split, int):
            train_len = len_dict - test_split
            splits = [train_len, test_split]
        elif isinstance(test_split, float):
            test_len = int(np.floor(test_split * len_dict))
            train_len = len_dict - test_len
            splits = [train_len, test_len]
        else:
            raise ValueError(f&#34;Unsupported type {type(test_split)}&#34;)
        indexes = list(range(len_dict))
        if shuffle:
            np.random.shuffle(indexes)
        train_idx, test_idx = indexes[:splits[0]], indexes[:splits[1]]

        dictionary_list = list(dictionary.items())

        train_dict = OrderedDict([
            value for idx, value in enumerate(dictionary_list)
            if idx in train_idx
        ])
        test_dict = OrderedDict([
            value for idx, value in enumerate(dictionary_list)
            if idx in test_idx
        ])
        return train_dict, test_dict

    def get_subject_dicts(
        self,
        step: str = &#39;step06_WMHz_new&#39;,
        modalities: List[str] = [&#39;T1w&#39;, &#39;FLAIR&#39;],
        labels: List[str] = [&#39;WMH&#39;],
    ) -&gt; Tuple[OrderedDict[Tuple[str, str], dict], OrderedDict[Tuple[str, str],
                                                               dict]]:
        &#34;&#34;&#34;
        Get paths to nii files for train images and labels.

        Returns
        -------
        _ : Tuple[List[Path], List[Path]]
            Paths to train images and labels.
        &#34;&#34;&#34;
        paths_dict = self.get_paths()
        train_paths_dict, test_paths_dict = self.split_dict(paths_dict)
        training_dict = OrderedDict()
        testing_dict = OrderedDict()

        # Get training dict
        for (subj_id, scan_id), path in train_paths_dict.items():
            training_dict[(subj_id, scan_id)] = {
                &#34;subj_id&#34;: subj_id,
                &#34;scan_id&#34;: scan_id
            }
            for mod in modalities:
                if mod == &#34;T1w&#34;:
                    t1_path = path / step / &#39;T1.nii&#39;
                    if t1_path.is_file():
                        training_dict[(subj_id, scan_id)].update(
                            {&#39;T1w&#39;: tio.ScalarImage(t1_path)})
                    else:
                        training_dict.pop((subj_id, scan_id), None)
                if mod == &#34;FLAIR&#34;:
                    flair_path = path / step / f&#39;{scan_id}_FLAIR.nii&#39;
                    if flair_path.is_file():
                        training_dict[(subj_id, scan_id)].update(
                            {&#39;FLAIR&#39;: tio.ScalarImage(flair_path)})
                    else:
                        training_dict.pop((subj_id, scan_id), None)

            for lab in labels:
                if lab == &#34;WMH&#34;:
                    wmh_path = path / step / f&#39;{scan_id}_FLAIR_wmh.nii&#39;
                    if wmh_path.is_file():
                        training_dict[(subj_id, scan_id)].update(
                            {&#39;WMH&#39;: tio.LabelMap(wmh_path)})
                    else:
                        training_dict.pop((subj_id, scan_id), None)

        # Get testing dict
        for (subj_id, scan_id), path in test_paths_dict.items():
            testing_dict[(subj_id, scan_id)] = {
                &#34;subj_id&#34;: subj_id,
                &#34;scan_id&#34;: scan_id
            }
            for mod in modalities:
                if mod == &#34;T1w&#34;:
                    t1_path = path / step / &#39;T1.nii&#39;
                    if t1_path.is_file():
                        testing_dict[(subj_id, scan_id)].update(
                            {&#39;T1w&#39;: tio.ScalarImage(t1_path)})
                    else:
                        testing_dict.pop((subj_id, scan_id), None)
                if mod == &#34;FLAIR&#34;:
                    flair_path = path / step / f&#39;{scan_id}_FLAIR.nii&#39;
                    if flair_path.is_file():
                        testing_dict[(subj_id, scan_id)].update(
                            {&#39;FLAIR&#39;: tio.ScalarImage(flair_path)})
                    else:
                        testing_dict.pop((subj_id, scan_id), None)

        return training_dict, testing_dict

    def get_subjects(self, train: bool = True) -&gt; List[tio.Subject]:
        &#34;&#34;&#34;
        Get TorchIO Subject train and test subjects.

        Parameters
        ----------
        train : bool, optional
            If True, return a loader for the train dataset, else for the
            validation dataset. Default = ``True``.

        Returns
        -------
        _ : List[tio.Subject]
            TorchIO Subject train or test subjects.
        &#34;&#34;&#34;
        if train:
            training_dict, _ = self.get_subject_dicts(
                step=self.step, modalities=self.modalities, labels=self.labels)
            train_subjects = []
            for _, subject_dict in training_dict.items():
                # &#39;image&#39; and &#39;label&#39; are arbitrary names for the images
                subject = tio.Subject(subject_dict)
                train_subjects.append(subject)
            return train_subjects

        _, testing_dict = self.get_subject_dicts(step=self.step,
                                                 modalities=self.modalities,
                                                 labels=self.labels)
        test_subjects = []
        for _, subject_dict in testing_dict.items():
            subject = tio.Subject(subject_dict)
            test_subjects.append(subject)

        return test_subjects

    def get_preprocessing_transforms(
        self,
        size: Optional[List[int]] = [256, 256, 256],
        t2w_present: bool = False,
        flair_present: bool = False,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        Get preprocessing transorms to apply to all subjects.

        Returns
        -------
        preprocess : tio.Compose
            All preprocessing steps that should be applied to all subjects.
        &#34;&#34;&#34;
        preprocess_list = []

        # Use standard orientation for all images
        preprocess_list.append(tio.ToCanonical())

        # if t2w_present and not flair_present:
        #     preprocess_list.append(tio.Resample(&#39;T2w&#39;))
        # elif not t2w_present and flair_present:
        #     preprocess_list.append(tio.Resample(&#39;FLAIR&#39;))
        # elif t2w_present and flair_present:
        #     preprocess_list.append(tio.Resample(&#39;FLAIR&#39;))
        # else:

        # Resample to T1w
        preprocess_list.append(tio.Resample(&#39;T1w&#39;))

        if size is None:
            train_subjects = self.get_subjects()
            test_subjects = self.get_subjects(train=False)
            shape = self.get_max_shape(train_subjects + test_subjects)
        else:
            shape = self.dims

        preprocess_list.extend([
            tio.RescaleIntensity((-1, 1)),
            tio.CropOrPad(shape),
            tio.EnsureShapeMultiple(8),  # for the U-Net
            tio.OneHot()
        ])

        return tio.Compose(preprocess_list)

    @staticmethod
    def get_augmentation_transforms() -&gt; Callable:
        &#34;&#34;&#34;&#34;
        Get augmentation transorms to apply to subjects during training.

        Returns
        -------
        augment : tio.Compose
            All augmentation steps that should be applied to subjects during
            training.
        &#34;&#34;&#34;
        augment = tio.Compose([
            tio.RandomAffine(),
            tio.RandomGamma(p=0.5),
            tio.RandomNoise(p=0.5),
            tio.RandomMotion(p=0.1),
            tio.RandomBiasField(p=0.25),
        ])
        return augment

    def default_transforms(self, stage: Optional[str] = None) -&gt; Callable:
        &#34;&#34;&#34;
        Default transforms and augmentations for the dataset.

        Parameters
        ----------
        stage: Optional[str]
            Either ``&#39;fit``, ``&#39;validate&#39;``, ``&#39;test&#39;``, or ``&#39;predict&#39;``.
            If stage = None, set-up all stages. Default = None.

        Returns
        -------
        _: Callable
            All preprocessing steps (and if ``&#39;fit&#39;``, augmentation steps too)
            that should be applied to the subjects.
        &#34;&#34;&#34;
        transforms = []
        t2w_present = bool(&#34;T2w&#34; in self.modalities)
        flair_present = bool(&#34;FLAIR&#34; in self.modalities)
        preprocess = self.get_preprocessing_transforms(
            size=self.dims,
            t2w_present=t2w_present,
            flair_present=flair_present)
        transforms.append(preprocess)
        if stage == &#34;fit&#34; or stage is None and self.use_augmentation:
            augment = self.get_augmentation_transforms()
            transforms.append(augment)

        return tio.Compose(transforms)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="radio.data.visiondatamodule.VisionDataModule" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule">VisionDataModule</a></li>
<li><a title="radio.data.basedatamodule.BaseDataModule" href="../basedatamodule.html#radio.data.basedatamodule.BaseDataModule">BaseDataModule</a></li>
<li>pytorch_lightning.core.datamodule.LightningDataModule</li>
<li>pytorch_lightning.core.hooks.CheckpointHooks</li>
<li>pytorch_lightning.core.hooks.DataHooks</li>
<li>pytorch_lightning.core.mixins.hparams_mixin.HyperparametersMixin</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_augmentation_transforms"><code class="name flex">
<span>def <span class="ident">get_augmentation_transforms</span></span>(<span>) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>"
Get augmentation transorms to apply to subjects during training.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>augment</code></strong> :&ensp;<code>tio.Compose</code></dt>
<dd>All augmentation steps that should be applied to subjects during
training.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_augmentation_transforms() -&gt; Callable:
    &#34;&#34;&#34;&#34;
    Get augmentation transorms to apply to subjects during training.

    Returns
    -------
    augment : tio.Compose
        All augmentation steps that should be applied to subjects during
        training.
    &#34;&#34;&#34;
    augment = tio.Compose([
        tio.RandomAffine(),
        tio.RandomGamma(p=0.5),
        tio.RandomNoise(p=0.5),
        tio.RandomMotion(p=0.1),
        tio.RandomBiasField(p=0.25),
    ])
    return augment</code></pre>
</details>
</dd>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.split_dict"><code class="name flex">
<span>def <span class="ident">split_dict</span></span>(<span>dictionary: collections.OrderedDict, test_split: Union[int, float] = 0.2, shuffle: bool = True) ‑> Tuple[collections.OrderedDict, collections.OrderedDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Split dict into two.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def split_dict(dictionary: OrderedDict,
               test_split: Union[int, float] = 0.2,
               shuffle: bool = True) -&gt; Tuple[OrderedDict, OrderedDict]:
    &#34;&#34;&#34;Split dict into two.&#34;&#34;&#34;
    len_dict = len(dictionary)
    if isinstance(test_split, int):
        train_len = len_dict - test_split
        splits = [train_len, test_split]
    elif isinstance(test_split, float):
        test_len = int(np.floor(test_split * len_dict))
        train_len = len_dict - test_len
        splits = [train_len, test_len]
    else:
        raise ValueError(f&#34;Unsupported type {type(test_split)}&#34;)
    indexes = list(range(len_dict))
    if shuffle:
        np.random.shuffle(indexes)
    train_idx, test_idx = indexes[:splits[0]], indexes[:splits[1]]

    dictionary_list = list(dictionary.items())

    train_dict = OrderedDict([
        value for idx, value in enumerate(dictionary_list)
        if idx in train_idx
    ])
    test_dict = OrderedDict([
        value for idx, value in enumerate(dictionary_list)
        if idx in test_idx
    ])
    return train_dict, test_dict</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.default_transforms"><code class="name flex">
<span>def <span class="ident">default_transforms</span></span>(<span>self, stage: Optional[str] = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Default transforms and augmentations for the dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Either <code>'fit</code>, <code>'validate'</code>, <code>'test'</code>, or <code>'predict'</code>.
If stage = None, set-up all stages. Default = None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>_</code></strong> :&ensp;<code>Callable</code></dt>
<dd>All preprocessing steps (and if <code>'fit'</code>, augmentation steps too)
that should be applied to the subjects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_transforms(self, stage: Optional[str] = None) -&gt; Callable:
    &#34;&#34;&#34;
    Default transforms and augmentations for the dataset.

    Parameters
    ----------
    stage: Optional[str]
        Either ``&#39;fit``, ``&#39;validate&#39;``, ``&#39;test&#39;``, or ``&#39;predict&#39;``.
        If stage = None, set-up all stages. Default = None.

    Returns
    -------
    _: Callable
        All preprocessing steps (and if ``&#39;fit&#39;``, augmentation steps too)
        that should be applied to the subjects.
    &#34;&#34;&#34;
    transforms = []
    t2w_present = bool(&#34;T2w&#34; in self.modalities)
    flair_present = bool(&#34;FLAIR&#34; in self.modalities)
    preprocess = self.get_preprocessing_transforms(
        size=self.dims,
        t2w_present=t2w_present,
        flair_present=flair_present)
    transforms.append(preprocess)
    if stage == &#34;fit&#34; or stage is None and self.use_augmentation:
        augment = self.get_augmentation_transforms()
        transforms.append(augment)

    return tio.Compose(transforms)</code></pre>
</details>
</dd>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_max_shape"><code class="name flex">
<span>def <span class="ident">get_max_shape</span></span>(<span>self, subjects: List[torchio.data.subject.Subject]) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get max shape.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>subjects</code></strong> :&ensp;<code>List[tio.Subject]</code></dt>
<dd>List of TorchIO Subject objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>_</code></strong> :&ensp;<code>np.ndarray((1, 3), np.int_)</code></dt>
<dd>Max height, width and depth across all subjects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_shape(self, subjects: List[tio.Subject]) -&gt; List[int]:
    &#34;&#34;&#34;
    Get max shape.

    Parameters
    ----------
    subjects : List[tio.Subject]
        List of TorchIO Subject objects.

    Returns
    -------
    _ : np.ndarray((1, 3), np.int_)
        Max height, width and depth across all subjects.
    &#34;&#34;&#34;
    dataset = self.dataset_cls(subjects)
    shapes = np.array([
        image.spatial_shape for subject in dataset
        for image in subject.get_images()
    ])
    return shapes.max(axis=0).tolist()</code></pre>
</details>
</dd>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_paths"><code class="name flex">
<span>def <span class="ident">get_paths</span></span>(<span>self) ‑> collections.OrderedDict[typing.Tuple[str, str], pathlib.Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Get subject and scan IDs and the respective paths from the study data
directory.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>_</code></strong> :&ensp;<code>Tuple[List[Path], List[Path]]</code></dt>
<dd>Paths to train images and labels.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paths(self) -&gt; OrderedDict[Tuple[str, str], Path]:
    &#34;&#34;&#34;
    Get subject and scan IDs and the respective paths from the study data
    directory.

    Returns
    -------
    _ : Tuple[List[Path], List[Path]]
        Paths to train images and labels.
    &#34;&#34;&#34;
    paths = OrderedDict()
    # 6-digit subject ID, followed by 6-digit scan ID
    regex = re.compile(r&#34;(\d{6})/(\d{6})&#34;)
    for item in self.root.glob(&#34;*/*&#34;):
        if item.is_dir() and not item.name.startswith(&#39;.&#39;):
            match = regex.search(str(item))
            if match is not None:
                subj_id, scan_id = match.groups()
                paths[(subj_id, scan_id)] = self.root / subj_id / scan_id

    return paths</code></pre>
</details>
</dd>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_preprocessing_transforms"><code class="name flex">
<span>def <span class="ident">get_preprocessing_transforms</span></span>(<span>self, size: Optional[List[int]] = [256, 256, 256], t2w_present: bool = False, flair_present: bool = False) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Get preprocessing transorms to apply to all subjects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>preprocess</code></strong> :&ensp;<code>tio.Compose</code></dt>
<dd>All preprocessing steps that should be applied to all subjects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_preprocessing_transforms(
    self,
    size: Optional[List[int]] = [256, 256, 256],
    t2w_present: bool = False,
    flair_present: bool = False,
) -&gt; Callable:
    &#34;&#34;&#34;
    Get preprocessing transorms to apply to all subjects.

    Returns
    -------
    preprocess : tio.Compose
        All preprocessing steps that should be applied to all subjects.
    &#34;&#34;&#34;
    preprocess_list = []

    # Use standard orientation for all images
    preprocess_list.append(tio.ToCanonical())

    # if t2w_present and not flair_present:
    #     preprocess_list.append(tio.Resample(&#39;T2w&#39;))
    # elif not t2w_present and flair_present:
    #     preprocess_list.append(tio.Resample(&#39;FLAIR&#39;))
    # elif t2w_present and flair_present:
    #     preprocess_list.append(tio.Resample(&#39;FLAIR&#39;))
    # else:

    # Resample to T1w
    preprocess_list.append(tio.Resample(&#39;T1w&#39;))

    if size is None:
        train_subjects = self.get_subjects()
        test_subjects = self.get_subjects(train=False)
        shape = self.get_max_shape(train_subjects + test_subjects)
    else:
        shape = self.dims

    preprocess_list.extend([
        tio.RescaleIntensity((-1, 1)),
        tio.CropOrPad(shape),
        tio.EnsureShapeMultiple(8),  # for the U-Net
        tio.OneHot()
    ])

    return tio.Compose(preprocess_list)</code></pre>
</details>
</dd>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_subject_dicts"><code class="name flex">
<span>def <span class="ident">get_subject_dicts</span></span>(<span>self, step: str = 'step06_WMHz_new', modalities: List[str] = ['T1w', 'FLAIR'], labels: List[str] = ['WMH']) ‑> Tuple[collections.OrderedDict[Tuple[str, str], dict], collections.OrderedDict[Tuple[str, str], dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get paths to nii files for train images and labels.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>_</code></strong> :&ensp;<code>Tuple[List[Path], List[Path]]</code></dt>
<dd>Paths to train images and labels.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subject_dicts(
    self,
    step: str = &#39;step06_WMHz_new&#39;,
    modalities: List[str] = [&#39;T1w&#39;, &#39;FLAIR&#39;],
    labels: List[str] = [&#39;WMH&#39;],
) -&gt; Tuple[OrderedDict[Tuple[str, str], dict], OrderedDict[Tuple[str, str],
                                                           dict]]:
    &#34;&#34;&#34;
    Get paths to nii files for train images and labels.

    Returns
    -------
    _ : Tuple[List[Path], List[Path]]
        Paths to train images and labels.
    &#34;&#34;&#34;
    paths_dict = self.get_paths()
    train_paths_dict, test_paths_dict = self.split_dict(paths_dict)
    training_dict = OrderedDict()
    testing_dict = OrderedDict()

    # Get training dict
    for (subj_id, scan_id), path in train_paths_dict.items():
        training_dict[(subj_id, scan_id)] = {
            &#34;subj_id&#34;: subj_id,
            &#34;scan_id&#34;: scan_id
        }
        for mod in modalities:
            if mod == &#34;T1w&#34;:
                t1_path = path / step / &#39;T1.nii&#39;
                if t1_path.is_file():
                    training_dict[(subj_id, scan_id)].update(
                        {&#39;T1w&#39;: tio.ScalarImage(t1_path)})
                else:
                    training_dict.pop((subj_id, scan_id), None)
            if mod == &#34;FLAIR&#34;:
                flair_path = path / step / f&#39;{scan_id}_FLAIR.nii&#39;
                if flair_path.is_file():
                    training_dict[(subj_id, scan_id)].update(
                        {&#39;FLAIR&#39;: tio.ScalarImage(flair_path)})
                else:
                    training_dict.pop((subj_id, scan_id), None)

        for lab in labels:
            if lab == &#34;WMH&#34;:
                wmh_path = path / step / f&#39;{scan_id}_FLAIR_wmh.nii&#39;
                if wmh_path.is_file():
                    training_dict[(subj_id, scan_id)].update(
                        {&#39;WMH&#39;: tio.LabelMap(wmh_path)})
                else:
                    training_dict.pop((subj_id, scan_id), None)

    # Get testing dict
    for (subj_id, scan_id), path in test_paths_dict.items():
        testing_dict[(subj_id, scan_id)] = {
            &#34;subj_id&#34;: subj_id,
            &#34;scan_id&#34;: scan_id
        }
        for mod in modalities:
            if mod == &#34;T1w&#34;:
                t1_path = path / step / &#39;T1.nii&#39;
                if t1_path.is_file():
                    testing_dict[(subj_id, scan_id)].update(
                        {&#39;T1w&#39;: tio.ScalarImage(t1_path)})
                else:
                    testing_dict.pop((subj_id, scan_id), None)
            if mod == &#34;FLAIR&#34;:
                flair_path = path / step / f&#39;{scan_id}_FLAIR.nii&#39;
                if flair_path.is_file():
                    testing_dict[(subj_id, scan_id)].update(
                        {&#39;FLAIR&#39;: tio.ScalarImage(flair_path)})
                else:
                    testing_dict.pop((subj_id, scan_id), None)

    return training_dict, testing_dict</code></pre>
</details>
</dd>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_subjects"><code class="name flex">
<span>def <span class="ident">get_subjects</span></span>(<span>self, train: bool = True) ‑> List[torchio.data.subject.Subject]</span>
</code></dt>
<dd>
<div class="desc"><p>Get TorchIO Subject train and test subjects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, return a loader for the train dataset, else for the
validation dataset. Default = <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>_</code></strong> :&ensp;<code>List[tio.Subject]</code></dt>
<dd>TorchIO Subject train or test subjects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subjects(self, train: bool = True) -&gt; List[tio.Subject]:
    &#34;&#34;&#34;
    Get TorchIO Subject train and test subjects.

    Parameters
    ----------
    train : bool, optional
        If True, return a loader for the train dataset, else for the
        validation dataset. Default = ``True``.

    Returns
    -------
    _ : List[tio.Subject]
        TorchIO Subject train or test subjects.
    &#34;&#34;&#34;
    if train:
        training_dict, _ = self.get_subject_dicts(
            step=self.step, modalities=self.modalities, labels=self.labels)
        train_subjects = []
        for _, subject_dict in training_dict.items():
            # &#39;image&#39; and &#39;label&#39; are arbitrary names for the images
            subject = tio.Subject(subject_dict)
            train_subjects.append(subject)
        return train_subjects

    _, testing_dict = self.get_subject_dicts(step=self.step,
                                             modalities=self.modalities,
                                             labels=self.labels)
    test_subjects = []
    for _, subject_dict in testing_dict.items():
        subject = tio.Subject(subject_dict)
        test_subjects.append(subject)

    return test_subjects</code></pre>
</details>
</dd>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.prepare_data"><code class="name flex">
<span>def <span class="ident">prepare_data</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Verify data directory exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_data(self, *args: Any, **kwargs: Any) -&gt; None:
    &#34;&#34;&#34;Verify data directory exists.&#34;&#34;&#34;
    if not is_dir_or_symlink(self.root):
        raise OSError(&#34;Study data directory not found!&#34;)</code></pre>
</details>
</dd>
<dt id="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, stage: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates train, validation and test collection of samplers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Either <code>'fit</code>, <code>'validate'</code>, <code>'test'</code>, or <code>'predict'</code>.
If stage = None, set-up all stages. Default = None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, stage: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;
    Creates train, validation and test collection of samplers.

    Parameters
    ----------
    stage: Optional[str]
        Either ``&#39;fit``, ``&#39;validate&#39;``, ``&#39;test&#39;``, or ``&#39;predict&#39;``.
        If stage = None, set-up all stages. Default = None.
    &#34;&#34;&#34;
    # dims = []
    if stage == &#34;fit&#34; or stage is None:
        train_transforms = (self.default_transforms()
                            if self.train_transforms is None else
                            self.train_transforms)

        val_transforms = (self.default_transforms()
                          if self.val_transforms is None else
                          self.val_transforms)

        train_subjects = self.get_subjects()
        # dims.append([self.get_max_shape(train_subjects)])
        self.train_dataset = self.dataset_cls(train_subjects,
                                              transform=train_transforms)
        self.val_dataset = self.dataset_cls(train_subjects,
                                            transform=val_transforms)

        self.validation = self.val_cls(train_dataset=self.train_dataset,
                                       val_dataset=self.val_dataset,
                                       batch_size=self.batch_size,
                                       shuffle=self.shuffle,
                                       num_workers=self.num_workers,
                                       pin_memory=self.pin_memory,
                                       drop_last=self.drop_last,
                                       num_folds=self.num_folds,
                                       seed=self.seed)

        self.validation.setup(self.val_split)
        self.size_train = self.validation.size_train
        self.size_val = self.validation.size_val

    if stage == &#34;test&#34; or stage is None:
        test_transforms = (self.default_transforms()
                           if self.test_transforms is None else
                           self.test_transforms)
        test_subjects = self.get_subjects(train=False)
        # dims.append([self.get_max_shape(test_subjects)])
        test_dataset = self.dataset_cls(test_subjects,
                                        transform=test_transforms)
        self.test_datasets.append(test_dataset)
        self.test_datasets.append(test_dataset)
        self.size_test = min([len(data) for data in self.test_datasets])

    if stage == &#34;predict&#34; or stage is None:
        predict_transforms = (self.default_transforms()
                              if self.test_transforms is None else
                              self.test_transforms)
        predict_subjects = self.get_subjects(train=False)
        predict_dataset = self.dataset_cls(predict_subjects,
                                           transform=predict_transforms)
        self.predict_datasets.append(predict_dataset)
        self.size_predict = min(
            [len(data) for data in self.predict_datasets])

    # self.dims = np.concatenate(dims, axis=0).max(axis=0).tolist()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="radio.data.visiondatamodule.VisionDataModule" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule">VisionDataModule</a></b></code>:
<ul class="hlist">
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.check_if_data_split" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.check_if_data_split">check_if_data_split</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.dataloader" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.dataloader">dataloader</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.dims" href="../basedatamodule.html#radio.data.basedatamodule.BaseDataModule.dims">dims</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.predict_dataloader" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.predict_dataloader">predict_dataloader</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.size_eval_dataset" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.size_eval_dataset">size_eval_dataset</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.size_train_dataset" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.size_train_dataset">size_train_dataset</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.teardown" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.teardown">teardown</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.test_dataloader" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.test_dataloader">test_dataloader</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.train_dataloader" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.train_dataloader">train_dataloader</a></code></li>
<li><code><a title="radio.data.visiondatamodule.VisionDataModule.val_dataloader" href="../visiondatamodule.html#radio.data.visiondatamodule.VisionDataModule.val_dataloader">val_dataloader</a></code></li>
</ul>
</li>
<li><code><b><a title="radio.data.basedatamodule.BaseDataModule" href="../basedatamodule.html#radio.data.basedatamodule.BaseDataModule">BaseDataModule</a></b></code>:
<ul class="hlist">
<li><code><a title="radio.data.basedatamodule.BaseDataModule.dataset_cls" href="../basedatamodule.html#radio.data.basedatamodule.BaseDataModule.dataset_cls">dataset_cls</a></code></li>
<li><code><a title="radio.data.basedatamodule.BaseDataModule.name" href="../basedatamodule.html#radio.data.basedatamodule.BaseDataModule.name">name</a></code></li>
</ul>
</li>
<li><code><b><a title="radio.data.basedatamodule.BaseDataModule" href="../basedatamodule.html#radio.data.basedatamodule.BaseDataModule">BaseDataModule</a></b></code>:
<ul class="hlist">
<li><code><a title="radio.data.basedatamodule.BaseDataModule.EXTRA_ARGS" href="../basedatamodule.html#radio.data.basedatamodule.BaseDataModule.EXTRA_ARGS">EXTRA_ARGS</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="radio.data.datamodules" href="index.html">radio.data.datamodules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="radio.data.datamodules.klu_apc2.plot_klu" href="#radio.data.datamodules.klu_apc2.plot_klu">plot_klu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule">KLUAPC2DataModule</a></code></h4>
<ul class="">
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.default_transforms" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.default_transforms">default_transforms</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_augmentation_transforms" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_augmentation_transforms">get_augmentation_transforms</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_max_shape" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_max_shape">get_max_shape</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_paths" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_paths">get_paths</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_preprocessing_transforms" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_preprocessing_transforms">get_preprocessing_transforms</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_subject_dicts" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_subject_dicts">get_subject_dicts</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_subjects" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.get_subjects">get_subjects</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.prepare_data" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.prepare_data">prepare_data</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.setup" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.setup">setup</a></code></li>
<li><code><a title="radio.data.datamodules.klu_apc2.KLUAPC2DataModule.split_dict" href="#radio.data.datamodules.klu_apc2.KLUAPC2DataModule.split_dict">split_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>